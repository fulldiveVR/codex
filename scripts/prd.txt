# Product Requirements Document: Generated Plugin Validation, Testing, and Correction (v3)

## 1. Introduction

This document outlines the requirements for enhancing the Codex CLI with capabilities to validate, test, and automatically correct **generated TypeScript plugin code snippets** (as defined in `instructions.md`) during execution. The goal is to improve the reliability and correctness of AI-generated plugins by integrating automated checks and feedback loops, evaluating existing utilities for potential use.

## 2. Goals

*   **Improve Plugin Quality:** Ensure generated TypeScript plugins are structurally valid, syntactically correct according to project standards, and functionally sound based on test cases before final output.
*   **Increase Reliability:** Reduce errors caused by incorrect or incomplete AI-generated plugin code.
*   **Automate Correction:** Implement a mechanism to automatically fix common issues identified during validation and testing based on structured feedback.
*   **Provide Actionable Feedback:** Offer clear, structured results from validation and testing to guide the automated correction process or manual refinement.

## 3. Functional Requirements

### 3.1. Plugin Code Validation

*   **FR-VALIDATE-01:** The system **SHOULD implement** capabilities to validate the structural integrity of generated TypeScript **plugin code snippets** against the expected framework format (e.g., presence and basic structure of `defineApp`, `actions`, `auth`). **Evaluation should be done** to determine if existing utilities (e.g., `plugin-validator.ts`, `structure-validator.ts`) can fulfill this requirement.
*   **FR-VALIDATE-02:** The system **SHOULD implement** capabilities to check generated TypeScript **plugin code snippets** for compilation errors using the TypeScript compiler (`tsc`), ensuring type safety and basic syntax correctness. **Evaluation should be done** to determine if existing utilities (e.g., `ts-compiler-validator.ts`) can fulfill this requirement. *(Note: Specific linting rules beyond basic compilation/structure might need separate consideration).*
*   **FR-VALIDATE-03:** Structured validation results (specific structural errors, compiler errors with line numbers and messages) from the implemented validation mechanisms MUST be captured and made available programmatically for the correction step.
*   **FR-VALIDATE-04:** The validation process should be integrated into the agent loop (`utils/agent/agent-loop.ts`) or made callable on demand against a specified **plugin code snippet**.

### 3.2. Universal Plugin Function Testing (Utilizing Sandbox)

*   **FR-TEST-01:** A universal function/tool (`testGeneratedPluginFunction`) MUST be created to execute a specific function (e.g., an Action's `run` method) within a generated **plugin snippet** using provided test cases.
*   **FR-TEST-02:** The testing tool MUST accept the generated **plugin code snippet** (as text), the name/key of the function to test, and a set of test data (input arguments/context simulating the `$` global variable, and expected output/behavior/state changes).
*   **FR-TEST-03:** The testing tool MUST execute the target function **within the existing secure sandbox environment** provided by utilities in `utils/agent/sandbox` (e.g., using `raw-exec.ts` or similar sandboxed execution mechanisms) to prevent side effects and ensure safe execution. Mocking of necessary framework parts (`$`, `defineApp`) will be required within this sandboxed context.
*   **FR-TEST-04:** The testing tool MUST compare the actual output/behavior of the function against the expected output/behavior defined in the test data.
*   **FR-TEST-05:** The testing tool MUST return **structured test results** indicating pass/fail status for each test case, including actual vs. expected outputs/state on failure. This constitutes the feedback for correction.

*Example Test Data Structure (Conceptual):*
```json
[
  {
    "description": "Test case 1: Action 'exampleAction' with valid input",
    "functionToTest": "exampleAction.run",
    "inputContext": {
      "step": {
        "parameters": { "inputParam": "hello" }
      },
      "auth": { "data": { "apiKey": "test-key" } }
    },
    "expectedBehavior": {
      "setActionItemCalledWith": { "raw": { "result": "Processed: hello" } }
    }
  },
  {
    "description": "Test case 2: Action 'exampleAction' with different input",
    "functionToTest": "exampleAction.run",
    "inputContext": {
      "step": {
        "parameters": { "inputParam": "world" }
      },
       "auth": { "data": { "apiKey": "test-key" } }
    },
    "expectedBehavior": {
      "setActionItemCalledWith": { "raw": { "result": "Processed: world" } }
    }
  }
]
```

### 3.3. Automated Correction (Integrating with Patching)

*   **FR-CORRECT-01:** Based on the **structured feedback** from the validation (FR-VALIDATE-03) and testing (FR-TEST-05) stages, the system SHOULD attempt to automatically correct the generated **plugin code snippet**.
*   **FR-CORRECT-02:** This correction process MAY involve invoking another AI model instance, providing it with the original **plugin code snippet**, the specific **structured error/failure results**, and instructions to fix them according to the plugin requirements and framework (`instructions.md`).
*   **FR-CORRECT-03:** The corrected **plugin code snippet** MUST be re-validated and re-tested (using the mechanisms defined in FR-VALIDATE-01, FR-VALIDATE-02, FR-TEST-01) to confirm the fix.
*   **FR-CORRECT-04:** The application of the corrected code SHOULD utilize the existing code patching mechanisms (e.g., `apply-patch.ts`, `parse-apply-patch.ts` found in `utils/agent/`) to modify the snippet in place or generate a new version.
*   **FR-CORRECT-05:** A mechanism should be in place within the agent loop (`utils/agent/agent-loop.ts`) to prevent infinite correction loops (e.g., limit correction attempts per snippet/error type).

## 4. Non-Functional Requirements

*   **NFR-PERF-01:** Validation and testing processes for plugin snippets should execute within acceptable time limits.
*   **NFR-SEC-01:** Plugin function execution during testing **must leverage the existing sandbox implementation** (`utils/agent/sandbox`) for security.
*   **NFR-LOG-01:** All validation, testing, and correction steps pertinent to plugin generation, including structured results and errors, MUST be logged.

## 5. Potential Components / Tools (Revised)

*   Validation Implementation (Handles structural/compiler checks - FR-VALIDATE-01, FR-VALIDATE-02). *Consider reusing/adapting `utils/validation` components.*
*   `testGeneratedPluginFunction(pluginCode: string, functionKey: string, testCases: PluginTestCase[]): Promise<PluginTestResult[]>` (New tool needed, leverages sandbox - FR-TEST-01 to FR-TEST-05).
*   `correctPluginCode(originalPluginCode: string, errors: (ValidationResult | PluginTestResult)[]): Promise<CorrectedCodeResult>` (New tool/logic needed, integrates with AI and patching - FR-CORRECT-01 to FR-CORRECT-04).
*   (Optional) `lintPluginCode(pluginCode: string): Promise<LinterResult>` (If specific ESLint-style linting beyond compiler/structure checks is desired).

## 6. Future Considerations

*   Support for testing asynchronous plugin functions and triggers.
*   Standardized test case generation based on plugin action/trigger definitions.
*   More sophisticated, rule-based correction strategies alongside AI correction.

## 7. Appendix

- **Example Plugin Structure:** (Reference the example provided by the user)
```typescript
// Example structure (import statements, dynamic fields, auth, actions, defineApp call)
import defineApp from '../../helpers/define-app';
// ... other imports
// ... dynamic fields, auth, actions definitions
export default defineApp({
  // ... IApp properties
});